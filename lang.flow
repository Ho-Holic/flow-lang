
########################################################
# 
# FLOW LANGUAGE SPEC v0.1
#
########################################################

----------------------------------------- Flow

-> function call

=> start in a new thread

----------------------------------------- Threads

thread_id = 
  foo => 1 2 3

join -> thread_id # or detach-> thread_id

----------------------------------------- Coroutine

range a to:b =
  loop a < b and a > 0
    yield -> a
    a += 1
  return -> ???    

range a to:b = loop | a < b and a > 0 | yield -> a | a += 1

loop 
  i = range -> 0 to 10
  print -> i

loop   
  print -> | range -> 0 10 |

loop   
  print -> range -> 0 10

----------------------------------------- Library

library HashTable
  take_hash obj = _ # use same function
  data HashTable = HashTable_v2

----------------------------------------- Import /Include

require -> HashTable

require -> HashTable from "https://www.github.com/blabla/hash.git"

require libName from:path =
  ???

----------------------------------------- Multiarguments  

# now you have N-args for 'path'

require libName [from:path...] =
  ???

# usage

require -> io from "C:/io.flow" 
              from "www.github.com/blabla/io.git"
  
----------------------------------------- Invariant (static assert) 

foo x ->
  invariant x < 3
  return -> x + 3

----------------------------------------- Variable

x = 3 
str = "cat"

----------------------------------------- Logical

# ok to have '(' and ')' in math

x = (true or false and true) xor false

x = 3 * (5-2)

----------------------------------------- Idempotent

data ColorChannel 
  Red 
  Green 
  Blue

idempotent ColorChannel -> Red # now red is basic 'default' value

----------------------------------------- Branch (if/switch/pattern match)

# vertical separator '|' used to write one-liners

# one-liner 'if'

foo -> branch | x < 3 | exit | relaunch

branch | isCompleted | true -> exit -> 3 | false -> relaunch -> 5 # it is ok to have extra '|'

branch isCompleted | true -> exit -> 3 | false -> relaunch -> 5


# normal 'if'

branch isCompleted
  true -> exit -> 3     
  false -> relaunch -> 5 

# short hand normal if, first case is always important one

branch isCompleted 
  exit -> 3
  relaunch -> 5

branch type 
  "Int"    -> calcForInt  
  "Double" -> calcForDouble             

scope calcForInt
  ???

scope calcForDouble
  ???

doc

  Different types of data

  1 2 3        # 1. similar types  
  1 "cat" true # 2. different types

  Similar type can be handled by 'graph'
  Different type can be handled by 'data'

----------------------------------------- Graph (Seq, Tree)

graph 1 2 3

graph 1 = "cat" # directional
      2 = "dog"
      1 -> 2

graph 1 <-> 2    # bi directional
      7 <-> 12      

graph 8 -> 3 # tree
      3 -> 1
      3 -> 6
      6 -> 4
      6 -> 7
      8 -> 10
      10 -> 14
      14 -> 13

#        8
#      /   \
#     3     10
#    / \      \
#   1   6     14
#      / \    / 
#     4  7   13

----------------------------------------- Seq (array)

# seq is graph with only nodes, no connections. Do we need syntactic sugar?

seq 1 2 3

seq "cat" "dog" "fish"

seq "cat"
    "dog"
    "fish"

x = seq 1 2 3    

count = size x # count is 3


----------------------------------------- Dict (Dictionary, Map, KeyValue)

# dict is graph with node 'key' and attached 'value'. 
# 1. it is not a tree
# 2. it is not sorted or some kind of processed

dict 1  = "cat"    
     2  = "dog"

dict "animal" = seq 1 2 3 
     "car"    = seq 5 6 7    

----------------------------------------- View (typedef on steroids)

data Point
     x
     y

view Size   -> Point
     width  -> x
     height -> y  

----------------------------------------- Scope

scope
  print -> 6
  print -> "I like cats"

scope lock_mutex # named scope
  do_stuff  

x = scope do_stuff  # what this can be?
  print -> 42
  
foo -> x  

----------------------------------------- Loops

processEvents x = branch x
  window   -> event x y z
  keyboard -> event key autoRepeat

loop processEvents

loop # good
  ???

loop x < 3 
  ???

--------------------------

scope sendData
  send -> to socket with data

loop needMoreStep
  sendData

--------------------------
        
--------------------------

loop x in seq 1 2 3 
  ???

loop [0, i < vec_size] # how make this work?
  ???  
  i += 1 # don't lie to programmer

--------------------------

----------------------------------------- Functions

x y = x * y    # good

x * y = x y

x y -> x * y   # bad

x * y <- x y   # bad

= x * y

----------------------------------------- Function Generation

# normal notation
set[Reset WrapAround Update]Modifier modifier = 
  m[Reset WrapAround Update] = modifier

# short notation (in development)
set[Reset WrapAround Update]Modifier modifier -> 
  m[...] = modifier 

----------------------------------------- Function name-rewrite (or look at Function Tags)

findIn x y source = ??? 

findIn x y source= rewrite -> find x` y` in `source

findIn 3 5 "/home/user/1.txt"

find 3 5 in "/home/user/1.txt"

----------------------------------------- Function Tags


find x y in:source = ???

find ->
  x:5 y:3 
  in source:"/home/user/1.txt"

find -> 5 3 in "/home/user/1.txt"

find -> in "/home/user/1.txt" 5 3 # allow rearrangement without explicit x:5 y :3

----------------------------------------- Function call

# -> you don't need to wrap arguments into () 

print -> n

foo -> 
  = x * x

foo -> 
  x * y =  x y

foo ->
  x = x * y 

foo -> x = 1 
       y = 255

loop [i <-list]
  print -> i # this is function call
  set   -> i 
           i+1      

point -> x y # constructor function
  
# void function call, how to deal with it?    
spawnEvent nothing = someEventSpawning -> x y z # full definition
spawnEvent _ = someEventSpawning -> x y z       # valid too
spawnEvent = someEventSpawning -> x y z         # ok too


view 1DPoint -> 2DPoint
      x      -> x
      y      -> x - y 


spawnEvent -> nothing


isReady nothing = data -> x y z

# Operator '?' can treated as '->.'
# but it can create abuse of spawnEvent? usage when function is not returning a boolean

foo -> branch | isReady? | a | b |

----------------------------------------- Function definition

printPoint x y = print -> "(@x, @y)" # normal function
           x y = print -> "(@x, @y)" # anonymous function
               = print -> "(@_, @_)" # anonymous function (discard args)


----------------------------------------- Logical operators

res = x equal y
res = x not equal y

res = x === y
res = x =/= y

-----------------------------------------  Top/Bottom types

#  any time can be a nothing so you can call foo -> 3 and value of 3 would be discarded
# because this is void function

foo nothing -> nothing

? = nothing
??? = nothing

----------------------------------------- Comments

# Single line comment. Why '#' ? It is good for drawing

################################
#                              #
# Box is very nice and usefull #
#                              #
################################

# No multiline comments

# What about documentation comments?

-- Also one liner doc? Why not...

----------------------------------------- Look it is awesome

x = 3 

----------------------------------------- Write code and split it

doc

  You can write some neat text here
  A lot of text
  Some function documentation and so on
  You can place it in different file
  It has more keywords to use, like:
    arg x -> Argument @self of type integer # @self is 'x' in processed doc



foo x -> x * x

doc foo # this is function documentation
  Fancy square function  
  args x of type integer

----------------------------------------- Use doc for big strings

# use doc for big strings is bad idea!!!
# need new keyword

x = 3
y = 7

text = doc 
  a lot of neat text here  
  with some  x = @x, y = @y
  this actually is multiline string

